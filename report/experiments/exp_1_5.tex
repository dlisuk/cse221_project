In our final experiment, we were to measure the time taken for a context switch to occur, both for ordinary processes and kernel threads. As with the last experiment, we were able to write code for testing kernel thread context switches, but unable to compile or run it. We will present code for both experiments, but we present data only for ordinary process context switches.
\newline
\newline
We induced context switches using the following method:

\noindent \begin{verbatim}
unsigned long measure() {

  unsigned long recv_time;

  write(p2c[1], "0", 1); // send dummy data to child process
  // read blocks parent, waits for child to respond with receipt time
  reset();
  read(c2p[0], (char*)&recv_time, sizeof(unsigned long)); 
  
  return recv_time;
}
\end{verbatim}

\noindent The child reads messages from the parent as follows:

\noindent \begin{verbatim}
while(1) {

  read(p2c[0], &inmsg, 1);
  GET_HIGH(recv_time);
  
  // send time of receipt
  write(c2p[1], (char*)&recv_time, sizeof(unsigned long));
}
\end{verbatim}

\noindent This method is fairly reliable. Immediately after the parent calls ``read", the parent blocks, since there is no way the child has received the message yet on this uniprocessor machine (assuming no context switch occurred between the sending and the read call). This frees the CPU for the child process, which receives the message and immediately records its time. The only overhead comes from the child executing the ``read" call. Assuming there are no other processes scheduled (which we took pains to ensure), this time difference is exactly one context switch.
\newline
\newline
The average time between the message is sent from the parent and received by the child is 25000 cycles, with a standard deviation of 5400. Given that the system call to {\tt read} produces an overhead, which was measured to be 2100 (std. dev. 165), we get an overall time of 22900, +- 5400.

\newpage

\noindent As for kernel threads, we use a similar technique (again though, the kernel thread experiments could not make use of the {\tt basic\_experiment} framework, since they had to be implemented as kernel modules);

\begin{verbatim}
int exp_init() {
  //init communication pipes
  pipe(p2c);
  pipe(c2p);

  ts = kthread_create(&reply_with_time,0,"0");
  
  for(int i = 0; i<MAX_N; ++i) {
    reset();
    write(p2c[1],"1",1);
    read(c2p[0],&in,1);
    fprintf(datafile, "%ul\n", recv_time); // set by child
  }
}

int reply_with_time(void *data) {
  while(1) {
    read(p2c[0], &in, 1);
    GET_HIGH(recv_time);
    write(c2p[1],"1",1);
  }
}
\end{verbatim}

\noindent As stated before, we were unable to get results for this experiment yet, due to problems compiling and running these tests.